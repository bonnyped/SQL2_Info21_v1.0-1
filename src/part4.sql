DROP TRIGGER IF EXISTS trg_tables_a_insert ON TableName_a;
DROP TRIGGER IF EXISTS trg_tables_b_insert ON TableName_b;
DROP TABLE IF EXISTS TableName_a;
DROP TABLE IF EXISTS TableName_b;
DROP TABLE IF EXISTS TableName_c;
DROP PROCEDURE IF EXISTS proc_drop_tables;
DROP PROCEDURE IF EXISTS proc_list_scalar_func;
DROP PROCEDURE IF EXISTS prc_get_scalar_functions;
DROP PROCEDURE IF EXISTS proc_drop_triggers;
-------------------------------------------
------- CREATE TABLES TableName_* ---------
-------------------------------------------
CREATE TABLE IF NOT EXISTS TableName_c (
    ID BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
    test_name VARCHAR NOT NULL
);

CREATE TABLE IF NOT EXISTS TableName_b (
    ID BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
    number_test BIGINT NOT NULL,
    "date" date NOT NULL DEFAULT current_date,
    FOREIGN KEY (number_test) REFERENCES TableName_c(ID)
);

CREATE TABLE IF NOT EXISTS TableName_a (
    ID BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
    number_test  BIGINT NOT NULL,
    "state" BOOLEAN DEFAULT false,
    "time_end" time NOT NULL DEFAULT current_time,
    FOREIGN KEY (number_test) REFERENCES TableName_c(id)
);
-------------------------------------------
-------- INSERT TABLES TableName_* --------
-------------------------------------------
INSERT INTO TableName_c (id,test_name)
VALUES (1, 'Test_one'),
        (2, 'Test_two'),
        (3, 'Test_three'),
        (4, 'Test_four'),
        (5, 'Test_five');
INSERT INTO TableName_b (id,number_test,"date")
VALUES (1, 3, '2023-12-11'),
        (2, 5, '2023-12-11'), 
        (3, 1, '2023-12-12'),
        (4, 2, '2023-12-12'),
        (5, 4, '2023-12-12'),
        (6, 1, '2023-12-13');
INSERT INTO TableName_a (id,number_test,"state","time_end")
VALUES (1, 3, true, '11:34:12'),
        (2, 5, true, '13:45:08'),
        (3, 1, false, '09:45:56'),
        (4, 2, true, '12:56:34'),
        (5, 4, false, '19:45:11'),
        (6, 1, true, '06:34:56');

-------------------------------------------
---------- CREATE TRIGGERS ----------------
-------------------------------------------
CREATE OR REPLACE FUNCTION  fnc_trg_tables_b_insert()
RETURNS TRIGGER AS 
$TransferredPoints$ 
BEGIN 
    RETURN NULL;
END;
$TransferredPoints$
LANGUAGE plpgsql;

CREATE TRIGGER trg_tables_b_insert
AFTER INSERT ON TableName_b
FOR EACH ROW EXECUTE FUNCTION fnc_trg_tables_b_insert();

CREATE OR REPLACE FUNCTION  fnc_trg_tables_a_insert()
RETURNS TRIGGER AS 
$TransferredPoints$ 
BEGIN 
    RETURN NULL;
END;
$TransferredPoints$
LANGUAGE plpgsql;

CREATE TRIGGER trg_tables_a_insert
AFTER INSERT ON TableName_a
    FOR EACH ROW EXECUTE FUNCTION fnc_trg_tables_a_insert();

-------------------------------------------
------------------ 01 ---------------------
-------------------------------------------

CREATE OR REPLACE PROCEDURE proc_drop_tables()
LANGUAGE plpgsql AS
$DROP_TABLE_NAME$
DECLARE
    list RECORD;
    statement1 TEXT;
BEGIN
    for list in
        select tablename
		from pg_catalog.pg_tables
		where schemaname != 'pg_catalog'
			and schemaname != 'information_schema'
			and tablename ~* '^TableName' ORDER BY 1
    LOOP
        statement1 := format('DROP TABLE IF EXISTS %s;',quote_ident(list.tablename));
        EXECUTE statement1;
        raise info 'DROP: %s ', quote_ident(list.tablename);
    END LOOP;
END;
$DROP_TABLE_NAME$;

-------------- test ex01 ------------------

-- call proc_drop_tables();

-------------------------------------------
------------------ 02 ---------------------
-------------------------------------------
CREATE OR REPLACE PROCEDURE proc_list_scalar_func( IN _result_one refcursor DEFAULT 'result')
LANGUAGE plpgsql AS
$LIST_SCALAR$
DECLARE
    list RECORD;
    list_out TEXT DEFAULT '';
    number_function INTEGER DEFAULT 0;
    name_function text DEFAULT '';
    list_parameters VARCHAR(255) DEFAULT '';
BEGIN
    for list in
        SELECT p.proname AS name_f, pg_get_function_arguments(p.oid) AS list_p--, p.proargtypes, p.prorows
        FROM pg_proc p
        INNER JOIN pg_namespace n on pronamespace = n.oid
        WHERE nspname = "current_schema"() AND  pg_get_function_arguments(p.oid) != '' AND p.prokind = 'f' AND p.prorows = 0
        GROUP BY proname,p.oid
    LOOP
        name_function := list.name_f;
        list_parameters  := list.list_p;
        IF name_function != '' THEN
            IF list_out = '' THEN
                list_out := format('%s(%s) ', name_function, list_parameters);
            ELSE
                list_out := format('%s, %s(%s) ',list_out,name_function,list_parameters);
            END IF;
            number_function := number_function + 1;
        END IF;
    END LOOP;
    OPEN _result_one for
        SELECT COALESCE(list_out, '''There are no scalar functions''') AS "ScalarFunctions", number_function AS "NumberFunctions";
        RAISE INFO '%', list_out; --?
END;
$LIST_SCALAR$;

-------------- test ex02 ------------------

BEGIN;
call proc_list_scalar_func();
FETCH ALL FROM "result";
END;

-- BEGIN;
-- call proc_list_scalar_func('s');
-- FETCH ALL FROM "s";
-- END;

-- BEGIN;
-- call proc_list_scalar_func('rcursor');
-- FETCH ALL FROM "rcursor";
-- END;

CREATE OR REPLACE PROCEDURE proc_list_scalar_func2( OUT list_out TEXT , OUT number_function INTEGER )
LANGUAGE plpgsql AS
$LIST_SCALAR2$
DECLARE
    list RECORD;
    name_function text DEFAULT '';
    list_parameters VARCHAR(255) DEFAULT '';
BEGIN
    list_out := '';
    number_function := 0;
    for list in
        SELECT p.proname AS name_f, pg_get_function_arguments(p.oid) AS list_p--, p.proargtypes, p.prorows
        FROM pg_proc p
        INNER JOIN pg_namespace n on pronamespace = n.oid
        WHERE nspname = "current_schema"() AND  pg_get_function_arguments(p.oid) != '' AND p.prokind = 'f' AND p.prorows = 0
        GROUP BY proname,p.oid
    LOOP
        name_function := list.name_f;
        list_parameters  := list.list_p;
        IF name_function != '' THEN
            IF list_out = '' THEN
                list_out := format('%s(%s)', name_function, list_parameters);
            ELSE
                list_out := format('%s, %s(%s) ',list_out,name_function,list_parameters);
            END IF;
            number_function := number_function + 1;
        END IF;
    END LOOP;
END;
$LIST_SCALAR2$;

-- test ex02

-- DO
-- $$
--     DECLARE
--         num_functions INTEGER;
--         function_list TEXT;
--     BEGIN
--         CALL proc_list_scalar_func2(function_list, num_functions);
--         RAISE INFO 'Found % scalar functions: %', num_functions, function_list;
--     END;
-- $$;

-------------------------------------------
------------------ 03 ---------------------
-------------------------------------------
DROP PROCEDURE IF EXISTS proc_drop_triggers;
CREATE OR REPLACE PROCEDURE proc_drop_triggers(IN _result_one refcursor DEFAULT 'result')
LANGUAGE plpgsql AS
$DROP_TRIGGER$
DECLARE
    list RECORD;
    statement1 TEXT;
    number_drop_triggers INTEGER DEFAULT 0;
BEGIN
    for list in
        SELECT trigger_name AS trigger_n, event_object_table AS table_n
        FROM  information_schema.triggers
    LOOP
        statement1 := format('DROP TRIGGER IF EXISTS %s ON %s;',quote_ident(list.trigger_n), quote_ident(list.table_n));
        EXECUTE statement1;
        number_drop_triggers := number_drop_triggers + 1;
        RAISE INFO 'DROP: %s for %s', quote_ident(list.trigger_n), quote_ident(list.table_n);
    END LOOP;
    OPEN _result_one for
        SELECT number_drop_triggers;
END;
$DROP_TRIGGER$;

-------------- test ex03 ------------------

-- BEGIN;
-- call proc_drop_triggers('rcursor');
-- FETCH ALL FROM "rcursor";
-- END;

-------------- check ex03 ------------------

-- SELECT event_object_table, trigger_name
-- FROM  information_schema.triggers

-------------------------------------------
------------------ 04 ---------------------
-------------------------------------------



 SELECT DISTINCT r.routine_name, r.routine_type 
FROM information_schema.routines AS r
WHERE r.specific_schema = 'public'
AND r.routine_definition ~* 'peer'; -- ???






-------------------------------------------
---------- CREATE Scalare F ----------------
-------------------------------------------

DROP FUNCTION IF EXISTS fnc_test_name;
CREATE OR REPLACE FUNCTION  fnc_test_name(x BIGINT)
RETURNS VARCHAR AS 
$TransferredPoints$
DECLARE
    y VARCHAR default 0;
BEGIN 
    y := (SELECT test_name FROM tablename_c WHERE id = x);
    RETURN y;
END;
$TransferredPoints$
LANGUAGE plpgsql;

select fnc_test_name(5);

CREATE FUNCTION add_numbers(num1 INTEGER, num2 INTEGER) RETURNS INTEGER AS $$
BEGIN
    RETURN num1 + num2;
END;
$$ LANGUAGE plpgsql; 

CREATE FUNCTION uppercase(text_value TEXT) RETURNS TEXT AS $$
BEGIN
    RETURN UPPER(text_value);
END;
$$ LANGUAGE plpgsql;


